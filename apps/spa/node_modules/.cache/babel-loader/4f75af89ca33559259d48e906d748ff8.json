{"ast":null,"code":"import { useEscapeKeydown as e } from \"@radix-ui/react-use-escape-keydown\";\nimport { useCallbackRef as t } from \"@radix-ui/react-use-callback-ref\";\nimport { useBodyPointerEvents as n } from \"@radix-ui/react-use-body-pointer-events\";\nimport { useComposedRefs as r } from \"@radix-ui/react-compose-refs\";\nimport { Primitive as s } from \"@radix-ui/react-primitive\";\nimport { composeEventHandlers as o } from \"@radix-ui/primitive\";\nimport * as i from \"react\";\nimport a from \"@babel/runtime/helpers/esm/extends\";\nconst u = /*#__PURE__*/i.createContext({\n  layers: new Set(),\n  layersWithOutsidePointerEventsDisabled: new Set(),\n  branches: new Set()\n});\nexport const DismissableLayer = /*#__PURE__*/i.forwardRef((l, m) => {\n  const {\n    disableOutsidePointerEvents: f = !1,\n    onEscapeKeyDown: p,\n    onPointerDownOutside: v,\n    onFocusOutside: b,\n    onInteractOutside: E,\n    onDismiss: y,\n    ...w\n  } = l,\n        h = i.useContext(u),\n        [D, x] = i.useState(null),\n        [, C] = i.useState({}),\n        L = r(m, e => x(e)),\n        P = Array.from(h.layers),\n        [O] = [...h.layersWithOutsidePointerEventsDisabled].slice(-1),\n        g = P.indexOf(O),\n        B = D ? P.indexOf(D) : -1,\n        R = h.layersWithOutsidePointerEventsDisabled.size > 0,\n        F = B >= g,\n        S = function (e) {\n    const n = t(e),\n          r = i.useRef(!1);\n    return i.useEffect(() => {\n      const e = e => {\n        if (e.target && !r.current) {\n          d(\"dismissableLayer.pointerDownOutside\", n, {\n            originalEvent: e\n          });\n        }\n\n        r.current = !1;\n      },\n            t = window.setTimeout(() => {\n        document.addEventListener(\"pointerdown\", e);\n      }, 0);\n\n      return () => {\n        window.clearTimeout(t), document.removeEventListener(\"pointerdown\", e);\n      };\n    }, [n]), {\n      onPointerDownCapture: () => r.current = !0\n    };\n  }(e => {\n    const t = e.target,\n          n = [...h.branches].some(e => e.contains(t));\n    F && !n && (null == v || v(e), null == E || E(e), e.defaultPrevented || null == y || y());\n  }),\n        W = function (e) {\n    const n = t(e),\n          r = i.useRef(!1);\n    return i.useEffect(() => {\n      const e = e => {\n        if (e.target && !r.current) {\n          d(\"dismissableLayer.focusOutside\", n, {\n            originalEvent: e\n          });\n        }\n      };\n\n      return document.addEventListener(\"focusin\", e), () => document.removeEventListener(\"focusin\", e);\n    }, [n]), {\n      onFocusCapture: () => r.current = !0,\n      onBlurCapture: () => r.current = !1\n    };\n  }(e => {\n    const t = e.target;\n    [...h.branches].some(e => e.contains(t)) || (null == b || b(e), null == E || E(e), e.defaultPrevented || null == y || y());\n  });\n\n  return e(e => {\n    B === h.layers.size - 1 && (null == p || p(e), e.defaultPrevented || null == y || y());\n  }), n({\n    disabled: f\n  }), i.useEffect(() => {\n    D && (f && h.layersWithOutsidePointerEventsDisabled.add(D), h.layers.add(D), c());\n  }, [D, f, h]), i.useEffect(() => () => {\n    D && (h.layers.delete(D), h.layersWithOutsidePointerEventsDisabled.delete(D), c());\n  }, [D, h]), i.useEffect(() => {\n    const e = () => C({});\n\n    return document.addEventListener(\"dismissableLayer.update\", e), () => document.removeEventListener(\"dismissableLayer.update\", e);\n  }, []), /*#__PURE__*/i.createElement(s.div, a({}, w, {\n    ref: L,\n    style: {\n      pointerEvents: R ? F ? \"auto\" : \"none\" : void 0,\n      ...l.style\n    },\n    onFocusCapture: o(l.onFocusCapture, W.onFocusCapture),\n    onBlurCapture: o(l.onBlurCapture, W.onBlurCapture),\n    onPointerDownCapture: o(l.onPointerDownCapture, S.onPointerDownCapture)\n  }));\n});\n/*#__PURE__*/\n\nexport const DismissableLayerBranch = /*#__PURE__*/i.forwardRef((e, t) => {\n  const n = i.useContext(u),\n        o = i.useRef(null),\n        c = r(t, o);\n  return i.useEffect(() => {\n    const e = o.current;\n    if (e) return n.branches.add(e), () => {\n      n.branches.delete(e);\n    };\n  }, [n.branches]), /*#__PURE__*/i.createElement(s.div, a({}, e, {\n    ref: c\n  }));\n});\n/*#__PURE__*/\n\nfunction c() {\n  const e = new Event(\"dismissableLayer.update\");\n  document.dispatchEvent(e);\n}\n\nfunction d(e, t, n) {\n  const r = n.originalEvent.target,\n        s = new CustomEvent(e, {\n    bubbles: !1,\n    cancelable: !0,\n    detail: n\n  });\n  return t && r.addEventListener(e, t, {\n    once: !0\n  }), !r.dispatchEvent(s);\n}\n\nexport const Root = DismissableLayer;\nexport const Branch = DismissableLayerBranch;","map":{"version":3,"mappings":"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","names":["DismissableLayerContext","React","createContext","layers","Set","layersWithOutsidePointerEventsDisabled","branches","DismissableLayer","forwardRef","props","forwardedRef","disableOutsidePointerEvents","onEscapeKeyDown","onPointerDownOutside","onFocusOutside","onInteractOutside","onDismiss","layerProps","context","useContext","node","setNode","useState","force","composedRefs","useComposedRefs","Array","from","highestLayerWithOutsidePointerEventsDisabled","slice","highestLayerWithOutsidePointerEventsDisabledIndex","indexOf","index","isBodyPointerEventsDisabled","size","isPointerEventsEnabled","pointerDownOutside","handlePointerDownOutside","useCallbackRef","isPointerInsideReactTreeRef","useRef","useEffect","handlePointerDown","event","target","current","dispatchCustomEvent","originalEvent","timerId","window","setTimeout","document","addEventListener","clearTimeout","removeEventListener","onPointerDownCapture","usePointerDownOutside","isPointerDownOnBranch","some","branch","contains","defaultPrevented","focusOutside","handleFocusOutside","isFocusInsideReactTreeRef","handleFocus","onFocusCapture","onBlurCapture","useFocusOutside","useEscapeKeydown","useBodyPointerEvents","disabled","add","dispatchUpdate","delete","handleUpdate","_react","Primitive","div","_babelRuntimeHelpersEsmExtends","ref","style","pointerEvents","undefined","composeEventHandlers","DismissableLayerBranch","Event","dispatchEvent","name","handler","detail","CustomEvent","bubbles","cancelable","once","Root","Branch"],"sources":["/Users/rajmahar/Desktop/SandBox/Collgate health/skin-health-frontend/node_modules/@radix-ui/react-dismissable-layer/dist/packages/react/dismissable-layer/src/DismissableLayer.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useBodyPointerEvents } from '@radix-ui/react-use-body-pointer-events';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\nconst CONTEXT_UPDATE = 'dismissableLayer.update';\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\n\nconst DismissableLayerContext = React.createContext({\n  layers: new Set<DismissableLayerElement>(),\n  layersWithOutsidePointerEventsDisabled: new Set<DismissableLayerElement>(),\n  branches: new Set<DismissableLayerBranchElement>(),\n});\n\ntype DismissableLayerElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DismissableLayerProps extends PrimitiveDivProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean;\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n  /**\n   * Handler called when the `DismissableLayer` should be dismissed\n   */\n  onDismiss?: () => void;\n}\n\nconst DismissableLayer = React.forwardRef<DismissableLayerElement, DismissableLayerProps>(\n  (props, forwardedRef) => {\n    const {\n      disableOutsidePointerEvents = false,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      ...layerProps\n    } = props;\n    const context = React.useContext(DismissableLayerContext);\n    const [node, setNode] = React.useState<DismissableLayerElement | null>(null);\n    const [, force] = React.useState({});\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const layers = Array.from(context.layers);\n    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1); // prettier-ignore\n    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled); // prettier-ignore\n    const index = node ? layers.indexOf(node) : -1;\n    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n\n    const pointerDownOutside = usePointerDownOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    });\n\n    const focusOutside = useFocusOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (isFocusInBranch) return;\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    });\n\n    useEscapeKeydown((event) => {\n      const isHighestLayer = index === context.layers.size - 1;\n      if (!isHighestLayer) return;\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    });\n\n    useBodyPointerEvents({ disabled: disableOutsidePointerEvents });\n\n    React.useEffect(() => {\n      if (!node) return;\n      if (disableOutsidePointerEvents) context.layersWithOutsidePointerEventsDisabled.add(node);\n      context.layers.add(node);\n      dispatchUpdate();\n    }, [node, disableOutsidePointerEvents, context]);\n\n    /**\n     * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect\n     * because a change to `disableOutsidePointerEvents` would remove this layer from the stack\n     * and add it to the end again so the layering order wouldn't be _creation order_.\n     * We only want them to be removed from context stacks when unmounted.\n     */\n    React.useEffect(() => {\n      return () => {\n        if (!node) return;\n        context.layers.delete(node);\n        context.layersWithOutsidePointerEventsDisabled.delete(node);\n        dispatchUpdate();\n      };\n    }, [node, context]);\n\n    React.useEffect(() => {\n      const handleUpdate = () => force({});\n      document.addEventListener(CONTEXT_UPDATE, handleUpdate);\n      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);\n    }, []);\n\n    return (\n      <Primitive.div\n        {...layerProps}\n        ref={composedRefs}\n        style={{\n          pointerEvents: isBodyPointerEventsDisabled\n            ? isPointerEventsEnabled\n              ? 'auto'\n              : 'none'\n            : undefined,\n          ...props.style,\n        }}\n        onFocusCapture={composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture)}\n        onBlurCapture={composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture)}\n        onPointerDownCapture={composeEventHandlers(\n          props.onPointerDownCapture,\n          pointerDownOutside.onPointerDownCapture\n        )}\n      />\n    );\n  }\n);\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayerBranch\n * -----------------------------------------------------------------------------------------------*/\n\nconst BRANCH_NAME = 'DismissableLayerBranch';\n\ntype DismissableLayerBranchElement = React.ElementRef<typeof Primitive.div>;\ninterface DismissableLayerBranchProps extends PrimitiveDivProps {}\n\nconst DismissableLayerBranch = React.forwardRef<\n  DismissableLayerBranchElement,\n  DismissableLayerBranchProps\n>((props, forwardedRef) => {\n  const context = React.useContext(DismissableLayerContext);\n  const ref = React.useRef<DismissableLayerBranchElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n\n  return <Primitive.div {...props} ref={composedRefs} />;\n});\n\nDismissableLayerBranch.displayName = BRANCH_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`\n * to mimic layer dismissing behaviour present in OS.\n * Returns props to pass to the node we want to check for outside events.\n */\nfunction usePointerDownOutside(onPointerDownOutside?: (event: PointerDownOutsideEvent) => void) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n        dispatchCustomEvent(POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      document.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      document.removeEventListener('pointerdown', handlePointerDown);\n    };\n  }, [handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\nfunction useFocusOutside(onFocusOutside?: (event: FocusOutsideEvent) => void) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n        dispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail);\n      }\n    };\n    document.addEventListener('focusin', handleFocus);\n    return () => document.removeEventListener('focusin', handleFocus);\n  }, [handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\nfunction dispatchUpdate() {\n  const event = new Event(CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\n\nfunction dispatchCustomEvent<E extends CustomEvent, OriginalEvent extends Event>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: OriginalEvent } & (E extends CustomEvent<infer D> ? D : never)\n) {\n  const target = detail.originalEvent.target as HTMLElement;\n  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });\n  if (handler) target.addEventListener(name, handler as EventListener, { once: true });\n  return !target.dispatchEvent(event);\n}\n\nconst Root = DismissableLayer;\nconst Branch = DismissableLayerBranch;\n\nexport {\n  DismissableLayer,\n  DismissableLayerBranch,\n  //\n  Root,\n  Branch,\n};\nexport type { DismissableLayerProps };\n"]},"metadata":{},"sourceType":"module"}